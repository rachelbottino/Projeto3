"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _http = require("http");

var _path = require("path");

var _invariant = require("@octetstream/invariant");

var _invariant2 = _interopRequireDefault(_invariant);

var _busboy = require("busboy");

var _busboy2 = _interopRequireDefault(_busboy);

var _lodash = require("lodash.merge");

var _lodash2 = _interopRequireDefault(_lodash);

var _mapListeners = require("./util/mapListeners");

var _mapListeners2 = _interopRequireDefault(_mapListeners);

var _getType = require("./util/getType");

var _getType2 = _interopRequireDefault(_getType);

var _isPlainObject = require("./util/isPlainObject");

var _isPlainObject2 = _interopRequireDefault(_isPlainObject);

var _readListeners = require("./util/readListeners");

var _readListeners2 = _interopRequireDefault(_readListeners);

var _objectFromEntries = require("./util/objectFromEntries");

var _objectFromEntries2 = _interopRequireDefault(_objectFromEntries);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const initializers = (0, _readListeners2.default)((0, _path.join)(__dirname, "listener"));

const defaults = {
  restoreTypes: true

  /**
   * Promise-based wrapper around Busboy. Inspired by async-busboy.
   * You'll get exactly what you've sent from your client app.
   * All files and other fields in a single object.
   *
   * @param {http.IncomingMessage} request â€“ HTTP request object
   * @param {object} [options = {}] - then-busboy options
   *
   * @return {Promise<object>}
   *
   * @api public
   *
   * @example
   *
   * // Simplest Koa.js middleware:
   * import busboy from "then-busboy"
   *
   * const toLowerCase = string => String.prototype.toLowerCase.call(string)
   *
   * const multipart = () => async (ctx, next) => {
   *   if (["post", "put"].includes(toLowerCase(ctx.method)) === false) {
   *     return await next()
   *   }
   *
   *   if (ctx.is("multipart/form-data") === false) {
   *     return await next()
   *   }
   *
   *   ctx.request.body = await busboy(ctx.req)
   *
   *   await next()
   * }
   *
   * export default multipart
   */
};const thenBusboy = (request, options = {}) => new Promise((resolve, reject) => {
  (0, _invariant2.default)(!(request instanceof _http.IncomingMessage), TypeError, "Request should be an instanceof http.IncomingMessage. Received %s", (0, _getType2.default)(request));

  (0, _invariant2.default)(!(0, _isPlainObject2.default)(options), TypeError, "Options should be an object. Received %s", (0, _getType2.default)(options));

  const headers = request.headers;

  options = (0, _lodash2.default)({}, defaults, options, { headers });

  const busboy = new _busboy2.default(request, options);

  const entries = [];

  const fulfill = (err, entry) => void (err ? reject(err) : entries.push(entry));

  const listeners = (0, _mapListeners2.default)(initializers, fn => fn(options, fulfill));

  // Set listeners before starting
  void (0, _mapListeners2.default)(listeners, (fn, name) => busboy.on(name, fn));

  function onFinish() {
    // Cleanup listeners
    void (0, _mapListeners2.default)(listeners, (fn, name) => busboy.removeListener(name, fn));

    try {
      return resolve((0, _objectFromEntries2.default)(entries));
    } catch (err) {
      return reject(err);
    }
  }

  busboy.on("error", reject).on("finish", onFinish);

  request.pipe(busboy);
});

exports.default = thenBusboy;