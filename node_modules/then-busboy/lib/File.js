"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _os = require("os");

var _fs = require("fs");

var _path = require("path");

var _stream = require("stream");

var _stream2 = _interopRequireDefault(_stream);

var _invariant = require("@octetstream/invariant");

var _invariant2 = _interopRequireDefault(_invariant);

var _nanoid = require("nanoid");

var _nanoid2 = _interopRequireDefault(_nanoid);

var _isPlainObject = require("./util/isPlainObject");

var _isPlainObject2 = _interopRequireDefault(_isPlainObject);

var _isString = require("./util/isString");

var _isString2 = _interopRequireDefault(_isString);

var _getType = require("./util/getType");

var _getType2 = _interopRequireDefault(_getType);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class File {
  /**
   * File class.
   *
   * @param {object} options
   *
   * @constructor
   *
   * @api private
   */
  constructor(options) {
    this.read = () => new Promise((resolve, reject) => {
      const data = [];

      const onData = ch => void data.push(ch);

      const onEnd = () => resolve(Buffer.concat(data));

      this.contents.on("error", reject).on("data", onData).on("end", onEnd);
    });

    this.write = path => new Promise((resolve, reject) => {
      if (!path || !(0, _isString2.default)(path)) {
        path = this.path;
      }

      this.contents.on("error", reject).on("end", resolve).pipe((0, _fs.createWriteStream)(path));
    });

    (0, _invariant2.default)(!(0, _isPlainObject2.default)(options), TypeError, "File options should be a plain object. Received", (0, _getType2.default)(options));

    const { contents, filename, enc, mime } = options;

    (0, _invariant2.default)(!contents, "File contents required.");

    (0, _invariant2.default)(!(contents instanceof _stream2.default), TypeError, "Contents should be a Stream. Received %s", (0, _getType2.default)(contents));

    (0, _invariant2.default)(!filename, "Filename required.");

    (0, _invariant2.default)(!(0, _isString2.default)(filename), TypeError, "Filename should be a string. Received %s", (0, _getType2.default)(filename));

    (0, _invariant2.default)(!enc, "File encoding required.");

    (0, _invariant2.default)(!(0, _isString2.default)(enc), TypeError, "File encoding should be a string. Received %s", (0, _getType2.default)(enc));

    (0, _invariant2.default)(!mime, "File mime type required.");

    (0, _invariant2.default)(!(0, _isString2.default)(mime), TypeError, "File mime type should be a string. Received %s", (0, _getType2.default)(mime));

    const ext = (0, _path.extname)(filename);
    const base = (0, _path.basename)(filename, ext);

    this.__contents = contents;
    this.__stream = contents;
    this.__filename = filename;
    this.__basename = base;
    this.__extname = ext;
    this.__mime = mime;
    this.__enc = enc;

    this.__path = (0, _path.join)((0, _os.tmpdir)(), `${(0, _nanoid2.default)()}_${this.filename}`);

    this.toJSON = this.toJSON.bind(this);
    this.inspect = this.inspect.bind(this);
  }

  get contents() {
    return this.__contents;
  }

  get stream() {
    return this.__stream;
  }

  get filename() {
    return this.__filename;
  }

  get basename() {
    return this.__basename;
  }

  get extname() {
    return this.__extname;
  }

  get enc() {
    return this.__enc;
  }

  get mime() {
    return this.__mime;
  }

  get path() {
    return this.__path;
  }

  /**
   * Read file contents from a stream
   *
   * @return {Promise<Buffer>}
   */


  /**
   * Write file contents to a disk.
   *
   * @param {string} path – path to where contents will be stored
   *  (default – this.path)
   *
   * @return {Promise}
   */


  toJSON() {
    return this.inspect();
  }

  inspect() {
    return `<File: ${this.filename}>`;
  }
}

exports.default = File;